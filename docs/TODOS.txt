TODOs for v1 of this thing:


Left side needs a “Calendars” function
* Will effectively be a view-only function that lets user pick a schedule, look at calendar, pick a version, maybe toggles for overrides / etc
* Pick a decent calendaring component for this
* May bake in an export to ics or something, that’s supposed to be trivial

Future function for generic web hook functionality
* Ask Claude what this would take — we’d normally just drop a teams plugin and move, but that’s challenging
* It’s a builder (daily / weekly / monthly), sends content somewhere, blah blah blah

Need some better validation on the cron expression guy
* build out those samples too

Rewrite the README.md file
* talk about reflections on claude / gemini





Normalize all the mapper functionality (object -> DTO)
* Rename the domain objects (Schedule, Rule, Deviation, Version, QueryLog)
* UI can still call it an override since that's the most accurate.
^^^ ScheduleMapper would contain toScheduleResponse, fromCreateScheduleRequest, etc.

public final class ScheduleMapper {
    private ScheduleMapper() {} // no instances

    // Domain -> Response (what we send to clients)
    public static ScheduleResponse toResponse(Schedule s) {
        return new ScheduleResponse(
            s.getId(),
            s.getTitle(),
            s.getStart().toString(), // or format however your API expects
            s.getEnd().toString(),
            s.getSomeList() == null ? List.of() :
                s.getSomeList().stream().map(SubMapper::toDto).toList()
        );
    }

    // CreateRequest -> Domain (used when creating a new schedule)
    public static Schedule toEntity(CreateScheduleRequest req) {
        Schedule s = new Schedule();
        s.setTitle(req.title());
        s.setStart(Instant.parse(req.startIso())); // or use a converter/helper
        s.setEnd(Instant.parse(req.endIso()));
        s.setSomeList(req.someList() == null ? List.of() :
            req.someList().stream().map(SubMapper::toEntity).toList());
        // DO NOT set DB-generated fields here (id, createdAt, etc.)
        return s;
    }

    // UpdateRequest -> apply to existing domain object
    // (chooses whether to mutate or return a new instance; mutating is common for JPA entities)
    public static void applyUpdate(UpdateScheduleRequest req, Schedule target) {
        if (req.title() != null) target.setTitle(req.title());
        if (req.startIso() != null) target.setStart(Instant.parse(req.startIso()));
        if (req.endIso() != null) target.setEnd(Instant.parse(req.endIso()));
        // handle collections carefully (replace vs partial merge)
        if (req.someList() != null) {
            target.setSomeList(req.someList().stream().map(SubMapper::toEntity).toList());
        }
    }
}



Let's brainstorm some ideas to test the behavior of Schedules, ScheduleRules, and ScheduleOverrides.

The typical workflow would be that we create a schedule, pick a rule to associate with it, then add / remove overrides.

I need to develop tests that focus on each schedule rule type so we can verify their behavior is as advertised.

From there, we could verify overrides.  For example, we pick the "ALL DAYS" rule on a new schedule, and then override TODAY to false.  Calling shouldRun for today should reflect this change.  We should also change some days in the future (turning them off and on), and making sure that works as well.

I need confidence all of this business logic actually works before putting the final polish on the app.

So, can you read through the project and tell me where each of these things are located?  I'll then read through where you've pointed me and see what needs to be added.  Feel free to suggest what you think should be added as well.

Please don't start changing things, let's build a plan first.
=============




